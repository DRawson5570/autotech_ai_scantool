"""
VIN decoder — offline make/model/year/engine decode from VIN.

Uses a flat SQLite database (built from NHTSA VPIC data) for instant
offline decode of any VIN.  Falls back to the NHTSA vPIC API for VINs
not found offline, caching results for future lookups.

The flat DB is generated by build_vin_db.py from the NHTSA VPIC source.

Usage:
    from addons.scan_tool.vin_decoder import decode_make_from_vin, decode_vin_full
    make = decode_make_from_vin("1FAHP3F20CL123456")  # -> "Ford"  (instant, offline)
    info = decode_vin_full("1FAHP3F20CL123456")       # -> {"make": "Ford", "model": "Focus", ...}
"""

import json
import logging
import os
import re
import sqlite3
import urllib.request
import urllib.error
from typing import Dict, Optional

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# WMI → Make  (first 3 characters of VIN)
#
# Entries are checked longest-prefix-first, so "1FA" beats "1F".
# Where multiple brands share a WMI group we map to the brand, not the
# parent corporation.  For DID-database purposes the calling code can
# normalise brands to a manufacturer group if needed (e.g. Chrysler/Dodge/Jeep/Ram).
# ---------------------------------------------------------------------------

_WMI_TABLE: dict[str, str] = {
    # ── Ford ──────────────────────────────────────────
    "1FA": "Ford",   "1FB": "Ford",   "1FC": "Ford",
    "1FD": "Ford",   "1FM": "Ford",   "1FT": "Ford",
    "1FV": "Ford",   "1ZV": "Ford",
    "2FA": "Ford",   "2FM": "Ford",   "2FT": "Ford",
    "3FA": "Ford",   "3FT": "Ford",
    "MAJ": "Ford",                     # Ford Thailand
    "NM0": "Ford",                     # Ford Turkey (Transit Connect, etc.)

    # ── Lincoln ───────────────────────────────────────
    "1LN": "Lincoln", "2LN": "Lincoln", "3LN": "Lincoln",
    "5LM": "Lincoln",

    # ── General Motors — Chevrolet ────────────────────
    "1G1": "Chevrolet", "1GC": "Chevrolet", "2G1": "Chevrolet",
    "3G1": "Chevrolet", "KL7": "Chevrolet",

    # ── GMC ───────────────────────────────────────────
    "1GT": "GMC", "2GT": "GMC", "3GT": "GMC",

    # ── Buick ─────────────────────────────────────────
    "1G4": "Buick", "2G4": "Buick",

    # ── Cadillac ──────────────────────────────────────
    "1G6": "Cadillac", "1GY": "Cadillac",

    # ── Pontiac (legacy) ──────────────────────────────
    "1G2": "Pontiac",

    # ── Chrysler / Stellantis ─────────────────────────
    "1C3": "Chrysler", "2C3": "Chrysler", "3C3": "Chrysler",
    "2C4": "Chrysler",

    # ── Dodge ─────────────────────────────────────────
    "1B3": "Dodge", "2B3": "Dodge", "3B3": "Dodge",
    "1B7": "Dodge", "2B7": "Dodge", "3B7": "Dodge",
    "1C4": "Dodge", "1C6": "Dodge",   # some overlap with Chrysler/Jeep — see Jeep below
    "2D3": "Dodge", "2D4": "Dodge", "2D7": "Dodge",

    # ── Jeep ──────────────────────────────────────────
    "1J4": "Jeep", "1J8": "Jeep",
    "1C4": "Jeep",   # modern Jeep (Cherokee/Compass/Wrangler JL use 1C4)
    # Note: 1C4 can be Chrysler or Jeep. 10th-char model year + 4th-8th resolve it.
    # For DID purposes, Jeep and Chrysler share the same FCA module set.

    # ── Ram ───────────────────────────────────────────
    "1C6": "Ram", "3C6": "Ram",
    "3D7": "Ram",

    # ── Toyota ────────────────────────────────────────
    "JTD": "Toyota", "JTE": "Toyota", "JTM": "Toyota",
    "JTN": "Toyota", "JTK": "Toyota", "JTL": "Toyota",
    "JTH": "Toyota",   # some Lexus badged under JTH
    "2T1": "Toyota", "2T3": "Toyota",
    "4T1": "Toyota", "4T3": "Toyota", "4T4": "Toyota",
    "5TD": "Toyota", "5TF": "Toyota", "5TN": "Toyota",

    # ── Lexus ─────────────────────────────────────────
    "JTJ": "Lexus",  "2T2": "Lexus",  "5TJ": "Lexus",
    "JTH": "Lexus",  # Lexus IS, RC, ES

    # ── Honda ─────────────────────────────────────────
    "JHM": "Honda", "1HG": "Honda", "2HG": "Honda",
    "5FN": "Honda", "5J6": "Honda", "19X": "Honda",

    # ── Acura ─────────────────────────────────────────
    "JH4": "Acura", "19U": "Acura",

    # ── Nissan ────────────────────────────────────────
    "JN1": "Nissan", "JN8": "Nissan",
    "1N4": "Nissan", "1N6": "Nissan",
    "3N1": "Nissan", "3N6": "Nissan",
    "5N1": "Nissan",

    # ── Infiniti ──────────────────────────────────────
    "JNK": "Infiniti",

    # ── Subaru ────────────────────────────────────────
    "JF1": "Subaru", "JF2": "Subaru", "4S3": "Subaru", "4S4": "Subaru",

    # ── Mazda ─────────────────────────────────────────
    "JM1": "Mazda", "JM3": "Mazda",
    "3MZ": "Mazda",

    # ── Mitsubishi ────────────────────────────────────
    "JA3": "Mitsubishi", "JA4": "Mitsubishi", "JA7": "Mitsubishi",
    "4A3": "Mitsubishi", "4A4": "Mitsubishi",

    # ── Hyundai ───────────────────────────────────────
    "KMH": "Hyundai", "5NP": "Hyundai", "5NM": "Hyundai",
    "KM8": "Hyundai",

    # ── Kia ───────────────────────────────────────────
    "KNA": "Kia", "KND": "Kia", "5XY": "Kia",

    # ── Genesis ───────────────────────────────────────
    "KMT": "Genesis",

    # ── BMW ───────────────────────────────────────────
    "WBA": "BMW", "WBS": "BMW", "WBY": "BMW",
    "5UX": "BMW", "5UJ": "BMW",

    # ── Mercedes-Benz ─────────────────────────────────
    "WDB": "Mercedes-Benz", "WDC": "Mercedes-Benz",
    "WDD": "Mercedes-Benz", "WDF": "Mercedes-Benz",
    "55S": "Mercedes-Benz", "4JG": "Mercedes-Benz",

    # ── Audi ──────────────────────────────────────────
    "WAU": "Audi", "WA1": "Audi",

    # ── Volkswagen ────────────────────────────────────
    "WVW": "Volkswagen", "WVG": "Volkswagen",
    "1VW": "Volkswagen", "3VW": "Volkswagen",

    # ── Porsche ───────────────────────────────────────
    "WP0": "Porsche", "WP1": "Porsche",

    # ── Volvo ─────────────────────────────────────────
    "YV1": "Volvo", "YV4": "Volvo", "7JR": "Volvo",

    # ── Tesla ─────────────────────────────────────────
    "5YJ": "Tesla", "7SA": "Tesla",

    # ── Rivian ────────────────────────────────────────
    "7PD": "Rivian",

    # ── Lucid ─────────────────────────────────────────
    "7LU": "Lucid",

    # ── Land Rover / Jaguar ───────────────────────────
    "SAL": "Land Rover", "SAJ": "Jaguar",

    # ── Mini ──────────────────────────────────────────
    "WMW": "Mini",

    # ── Fiat ──────────────────────────────────────────
    "ZFF": "Ferrari", "ZFA": "Fiat",
    "3C3": "Fiat",    # Fiat 500 (NA)

    # ── Suzuki ────────────────────────────────────────
    "JS1": "Suzuki", "JS2": "Suzuki",

    # ── Isuzu ─────────────────────────────────────────
    "JAA": "Isuzu", "JAL": "Isuzu",
}

# Pre-sorted longest-prefix first for greedy matching
_SORTED_WMIS = sorted(_WMI_TABLE.keys(), key=lambda k: (-len(k), k))


def decode_make_from_vin(vin: str) -> Optional[str]:
    """
    Return the vehicle make (brand name) from a VIN, or None if unknown.

    Checks local WMI table first; does NOT call external APIs.
    """
    if not vin or len(vin) < 3:
        return None
    vin = vin.strip().upper()
    wmi = vin[:3]

    # Exact 3-char lookup first
    if wmi in _WMI_TABLE:
        return _WMI_TABLE[wmi]

    # Try 2-char prefix (some WMI tables use 2)
    wmi2 = vin[:2]
    for prefix in _SORTED_WMIS:
        if wmi.startswith(prefix) or prefix.startswith(wmi2):
            return _WMI_TABLE[prefix]

    return None


def decode_manufacturer_group(make: str) -> str:
    """
    Map a brand name to its parent manufacturer group.

    Useful for DID-database scoping — brands under the same parent
    typically share the same module architecture and DID definitions.
    """
    _GROUPS = {
        "Ford": "Ford", "Lincoln": "Ford",
        "Chevrolet": "GM", "GMC": "GM", "Buick": "GM",
        "Cadillac": "GM", "Pontiac": "GM",
        "Chrysler": "Stellantis", "Dodge": "Stellantis",
        "Jeep": "Stellantis", "Ram": "Stellantis", "Fiat": "Stellantis",
        "Toyota": "Toyota", "Lexus": "Toyota",
        "Honda": "Honda", "Acura": "Honda",
        "Nissan": "Nissan", "Infiniti": "Nissan",
        "Hyundai": "Hyundai-Kia", "Kia": "Hyundai-Kia", "Genesis": "Hyundai-Kia",
        "BMW": "BMW", "Mini": "BMW",
        "Mercedes-Benz": "Mercedes-Benz",
        "Audi": "VAG", "Volkswagen": "VAG", "Porsche": "VAG",
        "Subaru": "Subaru", "Mazda": "Mazda", "Mitsubishi": "Mitsubishi",
        "Volvo": "Volvo",
        "Tesla": "Tesla", "Rivian": "Rivian", "Lucid": "Lucid",
        "Land Rover": "JLR", "Jaguar": "JLR",
    }
    return _GROUPS.get(make, make)


_VIN_PATTERN = re.compile(r"^[A-HJ-NPR-Z0-9]{17}$")


def is_valid_vin(vin: str) -> bool:
    """Quick check that a string looks like a 17-character VIN."""
    return bool(_VIN_PATTERN.match((vin or "").strip().upper()))


# ---------------------------------------------------------------------------
# VIN Year Decode (position 10)
# ---------------------------------------------------------------------------

_YEAR_CHAR_MAP: Dict[str, int] = {}
# 1980-2000: A=1980 ... Y=2000
for _i, _c in enumerate("ABCDEFGHJKLMNPRSTVWXY"):
    _YEAR_CHAR_MAP[_c] = 1980 + _i
# 2001-2009: 1=2001 ... 9=2009
for _i in range(1, 10):
    _YEAR_CHAR_MAP[str(_i)] = 2000 + _i
# 2010-2030: A=2010 ... (same letters cycle)
# Position 7 distinguishes pre/post-2010 in practice,
# but VPIC year-range matching resolves ambiguity.


def _decode_vin_year_char(ch: str) -> list:
    """
    Decode the 10th VIN character to possible model years.
    Returns a list of possible years, newer first (letters can mean 1980s or 2010s+).
    """
    ch = ch.upper()
    years = []
    base = _YEAR_CHAR_MAP.get(ch)
    if base is not None:
        # Letters cycle every 30 years (A=1980 or 2010, B=1981 or 2011, etc.)
        if base < 2001 and ch.isalpha():
            years.append(base + 30)  # Try newer year first (e.g. 2015 before 1985)
        years.append(base)
    return years


# ---------------------------------------------------------------------------
# Flat VIN Database — Offline Decode
# ---------------------------------------------------------------------------

# Flat DB generated by build_vin_db.py from NHTSA VPIC source
_FLAT_DB_PATHS = [
    os.path.join(os.path.dirname(__file__), "data", "vin_flat.db"),
    "/prod/autotech_ai/addons/scan_tool/data/vin_flat.db",
]

_flat_db_path: Optional[str] = None


def _get_flat_db_path() -> Optional[str]:
    """Find the flat VIN database file."""
    global _flat_db_path
    if _flat_db_path is not None:
        return _flat_db_path if os.path.exists(_flat_db_path) else None
    for path in _FLAT_DB_PATHS:
        resolved = os.path.realpath(path)
        if os.path.exists(resolved):
            _flat_db_path = resolved
            logger.debug(f"Flat VIN database found at {resolved}")
            return resolved
    logger.debug("Flat VIN database not found in any expected location")
    return None


def _match_pattern(key: str, pattern: str) -> bool:
    """
    Match a VIN key against a VPIC Pattern.Keys value.
    Pattern uses: * for single wildcard, [XY] for char class, [X-Z] for range.
    Converted from obdium's Rust implementation.
    """
    ki = 0
    pi = 0
    while pi < len(pattern):
        pc = pattern[pi]
        if pc == '*' or pc == '_':
            # Single character wildcard
            if ki >= len(key):
                return False
            ki += 1
            pi += 1
        elif pc == '%':
            # Match rest of string
            return True
        elif pc == '[':
            # Character class
            pi += 1
            negated = False
            if pi < len(pattern) and pattern[pi] == '^':
                negated = True
                pi += 1
            char_class = []
            while pi < len(pattern) and pattern[pi] != ']':
                c = pattern[pi]
                pi += 1
                if pi < len(pattern) and pattern[pi] == '-' and pi + 1 < len(pattern) and pattern[pi + 1] != ']':
                    pi += 1  # skip '-'
                    end = pattern[pi]
                    pi += 1
                    for ch in range(ord(c), ord(end) + 1):
                        char_class.append(chr(ch))
                else:
                    char_class.append(c)
            if pi < len(pattern):
                pi += 1  # skip ']'
            if ki >= len(key):
                return False
            kc = key[ki]
            contains = kc in char_class
            if (contains and negated) or (not contains and not negated):
                return False
            ki += 1
        else:
            # Literal character match
            if ki >= len(key):
                return False
            if key[ki] != pc:
                return False
            ki += 1
            pi += 1
    return ki >= len(key)


def _vin_to_key(vin: str) -> str:
    """
    Convert 17-char VIN to VPIC lookup key.
    Key = positions 4-8 + "|" + positions 10-17 (1-indexed).
    """
    return vin[3:8] + "|" + vin[9:17]


# ---------------------------------------------------------------------------
# VIN Lookups — permanent storage of decoded VINs
# ---------------------------------------------------------------------------

def _check_vin_lookup(vin: str) -> Optional[Dict[str, str]]:
    """Return a previously stored VIN decode result, or None."""
    db_path = _get_flat_db_path()
    if not db_path:
        return None
    try:
        conn = sqlite3.connect(f"file:{db_path}?mode=ro", uri=True, timeout=2)
        row = conn.execute(
            "SELECT result_json FROM vin_lookups WHERE vin = ?", (vin,)
        ).fetchone()
        conn.close()
        if row:
            logger.debug(f"VIN lookup found for {vin[:6]}...")
            return json.loads(row[0])
    except (sqlite3.Error, json.JSONDecodeError):
        pass
    return None


def _save_vin_lookup(vin: str, result: Dict[str, str], source: str = "nhtsa_api") -> None:
    """Permanently store a VIN decode result for future lookups."""
    db_path = _get_flat_db_path()
    if not db_path:
        return
    try:
        conn = sqlite3.connect(db_path, timeout=5)
        conn.execute(
            "INSERT OR REPLACE INTO vin_lookups (vin, result_json, source) VALUES (?, ?, ?)",
            (vin, json.dumps(result, ensure_ascii=False), source)
        )
        conn.commit()
        conn.close()
    except sqlite3.Error as e:
        logger.debug(f"Failed to save VIN lookup: {e}")


def decode_vin_vpic_offline(vin: str) -> Optional[Dict[str, str]]:
    """
    Decode a VIN using the local flat VIN database.

    The flat DB is built from NHTSA VPIC data by build_vin_db.py.
    All lookup table IDs are pre-resolved to human-readable text,
    so decoding is a simple pattern match — no multi-table JOINs.

    Returns:
        Dict with decoded fields (make, model, year, etc.) or None if
        the flat database is unavailable or VIN cannot be decoded.
    """
    db_path = _get_flat_db_path()
    if not db_path:
        return None

    vin = vin.strip().upper()
    if len(vin) != 17:
        return None

    wmi = vin[:3]
    year_char = vin[9]
    possible_years = _decode_vin_year_char(year_char)
    if not possible_years:
        return None

    key = _vin_to_key(vin)
    result: Dict[str, str] = {"vin": vin}

    try:
        conn = sqlite3.connect(f"file:{db_path}?mode=ro", uri=True, timeout=5)

        # Step 1: WMI info (make, manufacturer, vehicle_type)
        row = conn.execute(
            "SELECT make, manufacturer, vehicle_type FROM wmi_info WHERE wmi = ?",
            (wmi,)
        ).fetchone()
        if not row:
            conn.close()
            return None
        if row[0]:
            result["make"] = row[0]
        if row[1]:
            result["manufacturer"] = row[1]
        if row[2]:
            result["vehicle_type"] = row[2]

        # Step 2: Find patterns for this WMI + year, match against VIN key
        for year in possible_years:
            cursor = conn.execute(
                "SELECT keys, element, value FROM vin_patterns "
                "WHERE wmi = ? AND year_from <= ? "
                "AND (year_to >= ? OR year_to IS NULL)",
                (wmi, year, year)
            )
            rows = cursor.fetchall()
            if not rows:
                continue

            result["year"] = str(year)

            # Group patterns by element, first match wins per element
            by_element: Dict[str, list] = {}
            for pat_keys, element, value in rows:
                by_element.setdefault(element, []).append((pat_keys, value))

            for element, candidates in by_element.items():
                if element in result and element in ("make", "year"):
                    continue
                for pat_keys, value in candidates:
                    full_pat = pat_keys if "|" in pat_keys else pat_keys + "%"
                    if _match_pattern(key, full_pat):
                        result[element] = value
                        break

            break  # Found patterns for this year

        conn.close()
        return result if len(result) > 1 else None

    except sqlite3.Error as e:
        logger.debug(f"Flat DB error decoding VIN {vin[:6]}...: {e}")
        return None
    except Exception as e:
        logger.warning(f"Unexpected error decoding VIN {vin[:6]}...: {e}")
        return None


# ---------------------------------------------------------------------------
# Full VIN decode via NHTSA vPIC API (free, no key needed)
# ---------------------------------------------------------------------------

_NHTSA_URL = "https://vpic.nhtsa.dot.gov/api/vehicles/DecodeVin/{}?format=json"

# vPIC variable IDs we care about
_VPIC_FIELDS = {
    "Make":                 "make",
    "Model":                "model",
    "Model Year":           "year",
    "Displacement (L)":     "displacement_l",
    "Engine Number of Cylinders": "cylinders",
    "Fuel Type - Primary":  "fuel_type",
    "Drive Type":           "drive_type",
    "Body Class":           "body_class",
    "Vehicle Type":         "vehicle_type",
    "Plant City":           "plant_city",
    "Plant Country":        "plant_country",
    "Trim":                 "trim",
    "Series":               "series",
    "Engine Model":         "engine_model",
    "Transmission Style":   "transmission",
}


def decode_vin_full(vin: str, timeout: float = 3.0) -> Dict[str, str]:
    """
    Decode a VIN using offline flat database first, then NHTSA API fallback.

    Returns a dict with keys like:
      make, model, year, displacement_l, cylinders, fuel_type,
      drive_type, body_class, trim, engine_model, transmission, etc.

    Decode order:
      1. VIN cache (instant, previously decoded)
      2. Flat VIN database (instant, offline)
      3. NHTSA vPIC REST API (if offline decode incomplete)
      4. Local WMI table (last resort for make)

    Args:
        vin: 17-character VIN
        timeout: HTTP timeout in seconds for NHTSA API (default 3s)

    Returns:
        Dict of decoded fields.  Always has at least "vin" key.
        "make" is always populated if the VIN is recognisable.
    """
    vin = (vin or "").strip().upper()
    result: Dict[str, str] = {"vin": vin}

    if not is_valid_vin(vin):
        # Still try local WMI decode for partial VINs
        local_make = decode_make_from_vin(vin)
        if local_make:
            result["make"] = local_make
        return result

    # --- Step 0: Check stored lookups (previously decoded VINs) ---
    stored = _check_vin_lookup(vin)
    if stored:
        return stored

    # --- Step 1: Try offline flat DB decode ---
    vpic_result = decode_vin_vpic_offline(vin)
    if vpic_result:
        result.update(vpic_result)
        logger.debug(f"Flat DB decoded {len(vpic_result)} fields for VIN {vin[:6]}...")

    # Check if we have enough data (make + model at minimum)
    needs_api = "model" not in result or "year" not in result

    # --- Step 2: Try NHTSA API if offline was incomplete ---
    if needs_api:
        try:
            url = _NHTSA_URL.format(vin)
            req = urllib.request.Request(url, headers={"User-Agent": "AutotechAI/1.0"})
            with urllib.request.urlopen(req, timeout=timeout) as resp:
                data = json.loads(resp.read().decode("utf-8"))

            for item in data.get("Results", []):
                variable = item.get("Variable", "")
                value = (item.get("Value") or "").strip()
                if variable in _VPIC_FIELDS and value and value.lower() != "not applicable":
                    key = _VPIC_FIELDS[variable]
                    if key not in result:
                        result[key] = value

        except (urllib.error.URLError, urllib.error.HTTPError, OSError, json.JSONDecodeError) as e:
            logger.debug(f"NHTSA vPIC API unavailable for VIN {vin[:6]}...: {e}")
        except Exception as e:
            logger.warning(f"Unexpected error decoding VIN {vin[:6]}...: {e}")
    else:
        logger.debug(f"Offline decode sufficient for VIN {vin[:6]}..., skipping API call")

    # Normalise make to title case (NHTSA returns "FORD", we want "Ford")
    if "make" in result:
        raw = result["make"]
        if raw.upper() in {"BMW", "GMC"}:
            result["make"] = raw.upper()
        else:
            result["make"] = raw.title().replace("-", "-")  # "MERCEDES-BENZ" → "Mercedes-Benz"

    # Ensure make is populated — fall back to local WMI if API missed it
    if "make" not in result:
        local_make = decode_make_from_vin(vin)
        if local_make:
            result["make"] = local_make

    # Build a human-friendly engine description
    if "engine_desc" not in result:
        parts = []
        if result.get("displacement_l"):
            parts.append(f"{result['displacement_l']}L")
        if result.get("cylinders"):
            cyl = result["cylinders"]
            parts.append(f"V{cyl}" if int(cyl) >= 5 else f"I{cyl}" if int(cyl) <= 4 else f"{cyl}cyl")
        if result.get("fuel_type"):
            parts.append(result["fuel_type"])
        if parts:
            result["engine_desc"] = " ".join(parts)

    # --- Save to vin_lookups for future lookups ---
    if len(result) > 2:  # more than just vin + make
        source = "offline" if not needs_api else "nhtsa_api"
        _save_vin_lookup(vin, result, source)

    return result
